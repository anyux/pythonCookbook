#! /usr/bin/env python
# -*- coding: utf-8 -*-
# __author__ = "anyux"
# Date: 2018/11/13

'''
question:
我们正则尝试使用正则表达式对文本进行匹配,但识别出来的是最长的可能匹配.相反,我们想将其修改为找出最短的可能匹配.
'''

'''
解决方案:
这个问题通常会以匹配的文本被一对开始和结束分隔符包起来的时候出现(例如带引号的字符串).为了说明这个问题,请看下面的例子:
'''
import re
str_pat = re.compile(r'\"(.*)\"')
text1 = 'Computer says "no."'

print(str_pat.findall(text1))

'''
运行结果如下:
['no.']
'''

text2 = 'Computer says "no." Phone says "yes."'
print(str_pat.findall(text2))

'''
运行结果如下:
['no." Phone says "yes.']
'''
'''
在这个例子中,模式r'\"(.*)\"'尝试云匹配包含在引号中的文本.但是,*操作符在正则表达式中采用的是贪心策略,
所以匹配过程是基于找出最长的可能匹配来进行的.因此,在text2的例子中,它错误地匹配成2个被引号包围的字符串.
要解决这个问题,只要在模式中的*操作符加上?修饰符就可以了.示例如下:
'''
str_pat = re.compile(r'\"(.*?)\"')
print(str_pat.findall(text2))

'''
运行结果如下:

['no.', 'yes.']

'''

'''
这么做使用匹配过程不会以贪心方式进行,也就会产生出最短的匹配了.
'''

'''
讨论:
当前提到一个当编写含有句点(.)字符的正则表达式时常会遇到的问题.在模式中,句点除了换行符之外可匹配任意字符.但是,如果以开始和结束文件(
比如说引号)将句点括起来的话,在匹配过程中将尝试找出最长的可能匹配结果.这会导致匹配跳过多个开始或结束文本,
而将它们都包含在最长匹配中.在*或+后面添加一个?会强制将匹配算法调整为寻找最短的可能匹配
'''





''